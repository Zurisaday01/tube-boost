generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String          @id
  name          String // better auth requires name
  firstName     String // additional fields
  lastName      String // additional fields
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  Playlist      Playlist[]
  VideoMetadata VideoMetadata[]
  PlaylistNote  PlaylistNote[]
  ChannelRule   ChannelRule[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

// app tables and relations
// To accommodate both imported and manually created playlists, the youtubePlaylistId field is optional
model Playlist {
  id                String          @id @default(uuid())
  youtubePlaylistId String?
  source            PlaylistSource  @default(MANUAL)
  title             String
  user              User            @relation(fields: [userId], references: [id])
  userId            String
  videos            PlaylistVideo[]
  subcategories     Subcategory[]
  notes             PlaylistNote[]
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastSyncedAt      DateTime?
}

/**
 * Manual Playlist: source is MANUAL and youtubePlaylistId is null.
 * Imported Playlist: source is YOUTUBE and youtubePlaylistId has a value.
 */

enum PlaylistSource {
  YOUTUBE
  MANUAL
}

/**
 * Subcategories:
 * 0 â†’ "HTML Basics"
 * 1 â†’ "CSS Layouts"
 * 2 â†’ "React Hooks"
 * 3 â†’ "UX Patterns"
 */

model Subcategory {
  id         String          @id @default(uuid())
  playlist   Playlist        @relation(fields: [playlistId], references: [id])
  playlistId String
  name       String // e.g. "UX Videos", "Web Inspiration"
  orderIndex Int // order of subcategories inside playlist
  color      String          @default("#000000") // hex color code, e.g. "#ff0000"
  videos     PlaylistVideo[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
}

model Video {
  id             String          @id @default(uuid())
  youtubeVideoId String          @unique
  title          String
  channelId      String
  channelTitle   String
  duration       Int? // seconds, optional
  thumbnails     Json? // thumbnail URLs stored as JSON
  playlistVideos PlaylistVideo[]
  videoMetadatas VideoMetadata[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model PlaylistVideo {
  id            String       @id @default(uuid())
  playlist      Playlist     @relation(fields: [playlistId], references: [id])
  playlistId    String
  video         Video        @relation(fields: [videoId], references: [id])
  videoId       String
  subcategory   Subcategory? @relation(fields: [subcategoryId], references: [id])
  subcategoryId String? // nullable: video can be uncategorized
  orderIndex    Int // order inside the subcategory or playlist if no subcategory
  addedAt       DateTime? // when video was added to playlist (from YouTube)
}

model Tag {
  id             String             @id @default(uuid())
  name           String             @unique // e.g., "React", "Lo-fi"
  color          String? // optional hex color
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  // Relations
  videoMetadatas VideoMetadataTag[]
}

model VideoMetadataTag {
  id              String        @id @default(uuid())
  videoMetadata   VideoMetadata @relation(fields: [videoMetadataId], references: [id])
  videoMetadataId String
  tag             Tag           @relation(fields: [tagId], references: [id])
  tagId           String
}

model VideoMetadata {
  id        String             @id @default(uuid())
  video     Video              @relation(fields: [videoId], references: [id])
  videoId   String
  user      User               @relation(fields: [userId], references: [id])
  userId    String
  grade     Grade? // must-watch, optional, skip
  tags      VideoMetadataTag[]
  notes     String? // free text notes/comments
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
}

model PlaylistNote {
  id         String   @id @default(uuid())
  playlist   Playlist @relation(fields: [playlistId], references: [id])
  playlistId String
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  notes      String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model ChannelRule {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  channelId String // YouTube channel ID
  tags      String[] // tags to apply
  grade     Grade?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum Grade {
  MUST_WATCH
  OPTIONAL
  SKIP
}

// ðŸ’¡ Rule of thumb: Use grades for priority/importance, tags for custom categorization. That combination is flexible enough for most users without letting them define their own grades.
