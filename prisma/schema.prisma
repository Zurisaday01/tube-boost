generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String              @id
  name              String // better auth requires name
  firstName         String // additional fields
  lastName          String // additional fields
  email             String
  emailVerified     Boolean
  image             String?
  createdAt         DateTime
  updatedAt         DateTime
  sessions          Session[]
  accounts          Account[]
  Playlist          Playlist[]
  VideoMetadata     VideoMetadata[]
  PlaylistNote      PlaylistNote[]
  ChannelRule       ChannelRule[]
  PlaylistVideoNote PlaylistVideoNote[]
  TagGroup          TagGroup[]
  playlistTypes     PlaylistType[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

// Playlist types
model PlaylistType {
  id          String     @id @default(uuid())
  name        String // e.g. "Tutorials", "Music", "Documentaries"
  description String? // optional description
  color       String     @default("#000000")
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  user        User       @relation(fields: [userId], references: [id])
  userId      String
  playlists   Playlist[]

  @@unique([name, userId])
  @@index([userId, createdAt])
}

// app tables and relations
// To accommodate both imported and manually created playlists, the youtubePlaylistId field is optional
model Playlist {
  id                String          @id @default(uuid())
  youtubePlaylistId String?
  source            PlaylistSource  @default(MANUAL)
  title             String
  user              User            @relation(fields: [userId], references: [id])
  userId            String
  videos            PlaylistVideo[]
  subcategories     Subcategory[]
  notes             PlaylistNote[]
  playlistTypeId    String?
  // deleting a type does not delete the playlist, just sets to null
  playlistType      PlaylistType?   @relation(fields: [playlistTypeId], references: [id], onDelete: SetNull)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastSyncedAt      DateTime?
}

/**
 * Manual Playlist: source is MANUAL and youtubePlaylistId is null.
 * Imported Playlist: source is YOUTUBE and youtubePlaylistId has a value.
 */

enum PlaylistSource {
  YOUTUBE
  MANUAL
}

/**
 * Subcategories:
 * 0 → "HTML Basics"
 * 1 → "CSS Layouts"
 * 2 → "React Hooks"
 * 3 → "UX Patterns"
 */
// Transfers ownership to the playlist, so accessing user is possible through playlist
model Subcategory {
  id         String          @id @default(uuid())
  playlist   Playlist        @relation(fields: [playlistId], references: [id], onDelete: Cascade) // if playlist is deleted, delete this subcategory
  playlistId String
  name       String // e.g. "UX Videos", "Web Inspiration"
  orderIndex Int // order of subcategories inside playlist
  color      String          @default("#000000") // hex color code, e.g. "#ff0000"
  videos     PlaylistVideo[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
}

// Videos are the source data (YouTube)
model Video {
  id             String          @id @default(uuid())
  youtubeVideoId String          @unique
  title          String
  channelId      String
  channelTitle   String
  duration       Int? // seconds, optional
  thumbnails     Json? // thumbnail URLs stored as JSON
  playlistVideos PlaylistVideo[]
  videoMetadatas VideoMetadata[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

/**
 * Video → PlaylistVideo[] = one-to-many (a video can appear in multiple playlists or subcategories).
 * PlaylistVideo → Video = many-to-one (each playlist entry points to exactly one video).
 */

// PlaylistVideo is the wrapper with app-specific info
model PlaylistVideo {
  id            String             @id @default(uuid())
  playlist      Playlist           @relation(fields: [playlistId], references: [id], onDelete: Cascade) // if playlist is deleted, delete this relation
  playlistId    String
  video         Video              @relation(fields: [videoId], references: [id])
  videoId       String
  videoTags     VideoTag[]
  subcategory   Subcategory?       @relation(fields: [subcategoryId], references: [id])
  note          PlaylistVideoNote? // Optional one-to-one relation
  subcategoryId String? // nullable: video can be uncategorized
  orderIndex    Int // order inside the subcategory or playlist if no subcategory
  addedAt       DateTime? // when video was added to playlist (from YouTube)
}

model PlaylistVideoNote {
  id              String        @id @default(uuid())
  playlistVideo   PlaylistVideo @relation(fields: [playlistVideoId], references: [id], onDelete: Cascade) // if the video is deleted, delete the note too
  playlistVideoId String        @unique
  user            User          @relation(fields: [userId], references: [id])
  userId          String
  document        Json // rich text content stored as JSON (It's a big array of blocks in JSON format)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Tagging system ------------------------------------------------------------------
model TagGroup {
  id          String   @id @default(cuid())
  name        String // e.g. "Topic", "Difficulty", "Goal", "Mood"
  color       String   @default("#000000") // hex color code, e.g. "#ff0000"
  description String? // e.g. "General topic of the video", "How hard is it to follow along?"
  tags        Tag[]
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Ensure group names are unique per user
  @@unique([name, userId])
}

model Tag {
  id             String             @id @default(uuid())
  name           String // e.g., "React", "Lo-fi"
  color          String             @default("#000000") // hex color code, e.g. "#ff0000"
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  // Relations
  videos         VideoTag[]
  videoMetadatas VideoMetadataTag[]
  group          TagGroup           @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId        String

  channelRule ChannelRule[]

  // Ensure tag names are unique within their group
  @@unique([name, groupId])
}

model VideoTag {
  tagId           String
  tag             Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade) // if tag is deleted, delete this relation
  playlistVideo   PlaylistVideo @relation(fields: [playlistVideoId], references: [id], onDelete: Cascade) // if the playlist video is deleted, delete this relation
  playlistVideoId String

  @@id([playlistVideoId, tagId])
}

// ----------------------------------------------------------------

model VideoMetadataTag {
  id              String        @id @default(uuid())
  videoMetadata   VideoMetadata @relation(fields: [videoMetadataId], references: [id])
  videoMetadataId String
  tag             Tag           @relation(fields: [tagId], references: [id])
  tagId           String
}

model VideoMetadata {
  id        String             @id @default(uuid())
  video     Video              @relation(fields: [videoId], references: [id])
  videoId   String
  user      User               @relation(fields: [userId], references: [id])
  userId    String
  tags      VideoMetadataTag[]
  notes     String? // free text notes/comments
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
}

model PlaylistNote {
  id         String   @id @default(uuid())
  playlist   Playlist @relation(fields: [playlistId], references: [id])
  playlistId String
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  notes      String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model ChannelRule {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  channelId String // YouTube channel ID
  tags      Tag[] // tags to apply
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
